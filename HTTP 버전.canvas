{
	"nodes":[
		{"id":"fa400ad4bc3eef5d","type":"group","x":-620,"y":-460,"width":4120,"height":680,"label":"HTTP"},
		{"id":"a6b5f7b0d3fa51fc","type":"text","text":"## TCP\n```timestamp-url \n [[10분 테코톡] 🎃손너잘의 HTTP1.1, HTTP2, 그리고 QUIC (youtube.com)](https://www.youtube.com/watch?v=ZgSC5K1sUYM)\n ```\n- Transmission Control Protocol\n- 신뢰성을 가지는 프로토콜\n- IP 위에서 동작\n\n### 신뢰성을 확보하기 위한 3way handshake\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_5a319522-2834-45c8-8071-af592a99a1c3.jpeg)\n","x":-120,"y":260,"width":1160,"height":600},
		{"id":"df9636dcb3662cc9","type":"text","text":"## HTTP 1.0\n한번의 요청, 한번의 커넥션 수립 -> 엄청난 레이턴시\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_8c215302-3ab7-4d0a-b837-f7062ebeddfd.jpeg)\n\n### 느린 전송\n처음 연결이 수립된 TCP 커넥션이 전송할 수 있는 최대 데이터 한계 설정 -> 여러 번 데이터 송수신하는 과정에서 전송 가능한 최대 데이터 크기를 찾아나가는 과정 필요\n\n느린 전송으로 인한 데이터 송수신 여러번 발생 + 매요청마다 커넥션 연결 수립 과정 -> 엄청난 레이턴시\n\n### TCP 커넥션 재활용\nHTTP1.0 Keep-alive 헤더 : 한 번 송수신에 TCP 커넥션 끊어버리는 게 아닌 다음 연결에 재활용\n표준 X (멍청한 프록시 문제)","x":-620,"y":-440,"width":900,"height":640},
		{"id":"920009b6d354e705","type":"text","text":"## HTTP 1.1\n ```timestamp\n6:08\n```\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_f0842848-b83d-473b-bb52-2593b75be432.jpeg)\n지속 커넥션: TCP 커넥션 재활용\n요청과 응답의 순서 일치해야됨 -> 동기적인 요청과 응답 -> 레이턴시\n\n### 파이프라이닝\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_0f74f403-a093-466a-9345-83f38e747e2b.jpeg)\n서버에 처리할 작업이 담길 큐 생성 -> 요청 순서에 따른 응답(이전 요청에 대한 처리가 모두 완료 될때까지 처리가 완료 되지 않는 Head Of Line Blocking 문제 발생)\n\n##### 단점\n- Head Of Line Blocking\n- 서버에서 병렬 처리 시 응답을 메모리에 적재하고 있어야 함(리소스 낭비)\n- 응답 실패 시 클라이언트가 모든 리소스에 대한 요청을 처음부터 다시 보내야 함\n- 중계자 존재 시 파이프라인 호환성 문제\n- 중복 헤더(헤더의 상당 부분 중복 존재: 매번 요청 때마다 중복된 헤더 송신: 리소스 낭비)\n\n#### 멀티플렉싱\nTCP 커넥션 여러 개 생성(요청 병렬적으로 처리)\n```timestamp\n9:54\n```\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_f5b572f7-75b0-4959-867a-b2cad794efd7.jpeg)\n\n","x":360,"y":-440,"width":920,"height":640},
		{"id":"410a2dac68860596","type":"text","text":"## HTTP 2.0\n\n### 멀티플렉싱\nTCP 커넥션 여러개 생성X 단일 커넥션 안에서 여러 개의 데이터가 얽히지 않게 보내는 기법\n\n\n```timestamp \n 11:31\n ```\n\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_344b2bd7-8831-428c-8e72-cd4552f75515.jpeg)\n\n```timestamp \n 12:10\n ```\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_15665598-bd3f-4cd8-8420-d0665a64d67a.jpeg)\n식별자가 붙은 상태에서 하나의 TCP 커넥션 위에서 전송\n\n### 바이너리 프레이밍\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_f1a24e48-89f7-4ed6-969f-05a3a92b553c.jpeg)\n텍스트(HTTP 1.1) -> 바이너리 파일\n바이너리 파일 -> 여러 개의 프레임 나누어서 멀티플렉싱\n\n### 중복 헤더\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_f840179b-8358-489d-af2c-54b0b95ec539.jpeg)\n이전에 보낸 요청의 헤더 정보를 사전에 정적 테이블로 캐싱 -> 변경된 헤더 정보만 보냄\n허프만 코딩: 빈번하게 등장하는 키워드에 짧은 코드를 할당함으로써 헤더 용량 최소화\n\n\n#### 단점\n- TCP 프로토콜 자체에서 발생하는 HOL 문제(TCP 프로토콜 전송되는 데이터 순서 보장: 앞에 데이터 병목 발생 시 뒤에도 병목 발생)\n","x":1360,"y":-440,"width":1040,"height":640},
		{"id":"2923956769d95d42","type":"text","text":"## QUIC\nUDP 기반 신뢰성 보장 새로운 프로토콜 개발\n\n##### 독립 스트림\n하나의 커넥션 안에 여러개의 독립적인 스트림(하나의 스트림 문제 발생시 다른 스트림 사용)\n```timestamp \n 15:01\n ```\n![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/WrKXkW2BoTV5HR8o4w7F28Z61NB2/extension_screenshots/screenshot_default_eb6c6477-3f15-4b49-ae6c-500c7dd0da7e.jpeg)\nTCP: 하나의 스트림에 데이터들이 엮인 상태에서 전송\nQUIC : 요청별로 다른 스트림\n\n","x":2480,"y":-440,"width":1000,"height":640}
	],
	"edges":[
		{"id":"af2c10d116c0ee06","fromNode":"df9636dcb3662cc9","fromSide":"right","toNode":"920009b6d354e705","toSide":"left"},
		{"id":"efb3092eaee62b0a","fromNode":"920009b6d354e705","fromSide":"right","toNode":"410a2dac68860596","toSide":"left"},
		{"id":"50eec9efe3d39718","fromNode":"410a2dac68860596","fromSide":"right","toNode":"2923956769d95d42","toSide":"left"}
	]
}